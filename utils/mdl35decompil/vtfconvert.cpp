//========= Copyright © 1996-2001, Valve LLC, All rights reserved. ============
//
// Purpose: 
//
// $NoKeywords: $
//=============================================================================

#pragma warning(disable:4996) //I love old code style :)
#pragma warning(disable:4800) 
#pragma warning(disable:4018)


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <time.h>
#include "studio.h"
#include "optimize.h"
#include "vtfconvert.h"

extern imglib_t image;
extern void LogPrintf( char *fmt, ... );

#define IMAGE_MAXWIDTH	4096
#define IMAGE_MAXHEIGHT	4096

typedef enum 
{ 
	VTF_UNKNOWN = -1,		// image absent
	VTF_RGBA8888 = 0,		// PF_RGBA_32
	VTF_ABGR8888,		// unsupported
	VTF_RGB888,		// PF_RGB_24 
	VTF_BGR888,		// PF_BGR_24
	VTF_RGB565,		// unsupported 
	VTF_I8,			// PF_LUMINANCE
	VTF_IA88,			// PF_LUMINANCE_ALPHA
	VTF_P8,			// PF_INDEXED_24 ??
	VTF_A8,			// unsupported
	VTF_RGB888_BLUESCREEN,	// PF_RGB_24 - just fill alpha pixels with (0 0 255) color
	VTF_BGR888_BLUESCREEN,	// unsupported
	VTF_ARGB8888,		// PF_ARGB_32
	VTF_BGRA8888,		// unsupported
	VTF_DXT1,			// PF_DXT1
	VTF_DXT3,			// PF_DXT3
	VTF_DXT5,			// PF_DXT5
	VTF_BGRX8888,		// unsupported
	VTF_BGR565,		// unsupported
	VTF_BGRX5551,		// unsupported
	VTF_BGRA4444,		// unsupported
	VTF_DXT1_ONEBITALPHA,	// PF_DXT1 - loader automatically detected alpha bits
	VTF_BGRA5551,		// unsupported
	VTF_UV88,			// PF_LUMINANCE_ALPHA
	VTF_UVWQ8888,		// PF_RGBA_32
	VTF_RGBA16161616F,		// PF_ABGR_64_F ??
	VTF_RGBA16161616,		// unsupported
	VTF_UVLX8888,		// unsupported
	VTF_TOTALCOUNT
} vtf_format_t;

typedef enum
{
	// flags from the *.txt config file
	VF_POINTSAMPLE	= BIT(0),
	VF_TRILINEAR	= BIT(1),
	VF_CLAMPS		= BIT(2),
	VF_CLAMPT		= BIT(3),
	VF_ANISOTROPIC	= BIT(4),
	VF_HINT_DXT5	= BIT(5),
	VF_NOCOMPRESS	= BIT(6),
	VF_NORMAL		= BIT(7),
	VF_NOMIP		= BIT(8),
	VF_NOLOD		= BIT(9),
	VF_MINMIP		= BIT(10),
	VF_PROCEDURAL	= BIT(11),
	
	// these are automatically generated by vtex from the texture data.
	VF_ONEBITALPHA	= BIT(12),
	VF_EIGHTBITALPHA	= BIT(13),

	// newer flags from the *.txt config file
	VF_ENVMAP		= BIT(14),
	VF_RENDERTARGET	= BIT(15),
	VF_DEPTHRENDERTARGET= BIT(16),
	VF_NODEBUGOVERRIDE	= BIT(17),
	VF_SINGLECOPY	= BIT(18),
	VF_ONEALPHAMIP	= BIT(19),
	VF_PREMULTCOLOR	= BIT(20),
	VF_NORMALTODUDV	= BIT(21),
	VF_ALPHATESTMIPGEN	= BIT(22),
	VF_NODEPTHBUFFER	= BIT(23),
	VF_NICEFILTERED	= BIT(24),
	VF_LASTFLAG	= BIT(24),
} vtf_flags_t;

// imagelib global settings
typedef enum
{
	IL_DDS_HARDWARE	= BIT(0),	// instance have dds hardware support (disable software unpacker)
	IL_ATI_FLOAT_EXT	= BIT(1),	// reinstall float images glmask for ati extensions
	IL_NV_FLOAT_EXT	= BIT(2),	// reinstall float images glmask for nv extensions
	IL_USE_LERPING	= BIT(3),	// lerping images during resample
	IL_KEEP_8BIT	= BIT(4),	// don't expand paletted images
	IL_ALLOW_OVERWRITE	= BIT(5),	// allow to overwrite stored images
	IL_IGNORE_MIPS	= BIT(6),	// ignore mip-levels to loading
} ilFlags_t;

enum
{
	LUMP_NORMAL = 0,
	LUMP_TRANSPARENT,
	LUMP_DECAL,
	LUMP_QFONT,
	LUMP_EXTENDED		// bmp images have extened palette with alpha-channel
};

// dirty Valve tricks with compiler features...
#pragma pack( 1 )
__declspec(align( 16 )) typedef struct vtf_s
{
	int		ident;		// must matched with VTFHEADER
	int		ver_major;	// current version is 7
	int		ver_minor;	// 1 or 2
	int		hdr_size;		// ver 7.1 == 64 bytes, ver 7.2 == 80 bytes
	word		width;		// maxwidth 2048
	word		height;		// maxheight 2048
	uint		flags;		// misc image flags
	int		num_frames;	// sprite frames
	int		start_frame;	// ???
	vec4_t		reflectivity;	// vrad precomputed texcolor
	float		bumpScale;	// ovverided from vmt file
	vtf_format_t	imageFormat;	// see vtf_format_t for details
	byte		numMipLevels;	// never reached 255 mipLevels

	// probably it's used for WorldCraft texture explorer
	vtf_format_t	lowResImageFormat;	
	byte		lowResImageWidth;	// maxWidth = 256
	byte		lowResImageHeight;	// maxHeight = 256	

	// 20 additonal bytes for subversion 2 probably used for HDR settings
	int		unknown[4]; 
} vtf_t;
#pragma pack()

typedef struct bpc_desc_s
{
	int	format;	// pixelformat
	char	name[16];	// used for debug
	uint	glFormat;	// RGBA format
	uint	glType;	// pixel size (byte, short etc)
	int	bpp;	// channels (e.g. rgb = 3, rgba = 4)
	int	bpc;	// sizebytes (byte, short, float)
	int	block;	// blocksize < 0 needs alternate calc
} bpc_desc_t;

typedef struct { uint b:5; uint g:6; uint r:5; } color16;

uint d_8to24table[256];
uint d_8toQ1table[256];
bool q1palette_init = false;

static byte palette_q1[768] =
{
0,0,0,15,15,15,31,31,31,47,47,47,63,63,63,75,75,75,91,91,91,107,107,107,123,123,123,139,139,139,155,155,155,171,
171,171,187,187,187,203,203,203,219,219,219,235,235,235,15,11,7,23,15,11,31,23,11,39,27,15,47,35,19,55,43,23,63,
47,23,75,55,27,83,59,27,91,67,31,99,75,31,107,83,31,115,87,31,123,95,35,131,103,35,143,111,35,11,11,15,19,19,27,
27,27,39,39,39,51,47,47,63,55,55,75,63,63,87,71,71,103,79,79,115,91,91,127,99,99,139,107,107,151,115,115,163,123,
123,175,131,131,187,139,139,203,0,0,0,7,7,0,11,11,0,19,19,0,27,27,0,35,35,0,43,43,7,47,47,7,55,55,7,63,63,7,71,71,
7,75,75,11,83,83,11,91,91,11,99,99,11,107,107,15,7,0,0,15,0,0,23,0,0,31,0,0,39,0,0,47,0,0,55,0,0,63,0,0,71,0,0,79,
0,0,87,0,0,95,0,0,103,0,0,111,0,0,119,0,0,127,0,0,19,19,0,27,27,0,35,35,0,47,43,0,55,47,0,67,55,0,75,59,7,87,67,7,
95,71,7,107,75,11,119,83,15,131,87,19,139,91,19,151,95,27,163,99,31,175,103,35,35,19,7,47,23,11,59,31,15,75,35,19,
87,43,23,99,47,31,115,55,35,127,59,43,143,67,51,159,79,51,175,99,47,191,119,47,207,143,43,223,171,39,239,203,31,255,
243,27,11,7,0,27,19,0,43,35,15,55,43,19,71,51,27,83,55,35,99,63,43,111,71,51,127,83,63,139,95,71,155,107,83,167,123,
95,183,135,107,195,147,123,211,163,139,227,179,151,171,139,163,159,127,151,147,115,135,139,103,123,127,91,111,119,
83,99,107,75,87,95,63,75,87,55,67,75,47,55,67,39,47,55,31,35,43,23,27,35,19,19,23,11,11,15,7,7,187,115,159,175,107,
143,163,95,131,151,87,119,139,79,107,127,75,95,115,67,83,107,59,75,95,51,63,83,43,55,71,35,43,59,31,35,47,23,27,35,
19,19,23,11,11,15,7,7,219,195,187,203,179,167,191,163,155,175,151,139,163,135,123,151,123,111,135,111,95,123,99,83,
107,87,71,95,75,59,83,63,51,67,51,39,55,43,31,39,31,23,27,19,15,15,11,7,111,131,123,103,123,111,95,115,103,87,107,
95,79,99,87,71,91,79,63,83,71,55,75,63,47,67,55,43,59,47,35,51,39,31,43,31,23,35,23,15,27,19,11,19,11,7,11,7,255,
243,27,239,223,23,219,203,19,203,183,15,187,167,15,171,151,11,155,131,7,139,115,7,123,99,7,107,83,0,91,71,0,75,55,
0,59,43,0,43,31,0,27,15,0,11,7,0,0,0,255,11,11,239,19,19,223,27,27,207,35,35,191,43,43,175,47,47,159,47,47,143,47,
47,127,47,47,111,47,47,95,43,43,79,35,35,63,27,27,47,19,19,31,11,11,15,43,0,0,59,0,0,75,7,0,95,7,0,111,15,0,127,23,
7,147,31,7,163,39,11,183,51,15,195,75,27,207,99,43,219,127,59,227,151,79,231,171,95,239,191,119,247,211,139,167,123,
59,183,155,55,199,195,55,231,227,87,127,191,255,171,231,255,215,255,255,103,0,0,139,0,0,179,0,0,215,0,0,255,0,0,255,
243,147,255,247,199,255,255,255,159,91,83
};

// soul of ImageLib - table of image format constants 
const bpc_desc_t PFDesc[] =
{
{PF_UNKNOWN,	"raw",	0x1908,	0x1401, 0,  0,  0 },
{PF_INDEXED_24,	"pal 24",	0x1908,	0x1401, 1,  1,  0 }, // expand data to RGBA buffer
{PF_INDEXED_32,	"pal 32",	0x1908,	0x1401, 1,  1,  0 },
{PF_RGBA_32,	"RGBA 32",0x1908,	0x1401, 4,  1, -4 },
{PF_BGRA_32,	"BGRA 32",0x80E1,	0x1401, 4,  1, -4 },
{PF_ARGB_32,	"ARGB 32",0x1908,	0x8366, 4,  1, -4 },
{PF_ABGR_64,	"ABGR 64",0x80E1,	0x1401, 4,  2, -8 },
{PF_RGB_24,	"RGB 24",	0x1908,	0x1401, 3,  1, -3 },
{PF_BGR_24,	"BGR 24",	0x80E0,	0x1401, 3,  1, -3 },
{PF_RGB_16,	"RGB 16",	0x8054,	0x8364, 3,  2, 16 }, // FIXME: do revision
{PF_DXT1,		"DXT1",	0x1908,	0x1401, 4,  1,  8 },
{PF_DXT2,		"DXT2",	0x1908,	0x1401, 4,  1, 16 },
{PF_DXT3,		"DXT3",	0x1908,	0x1401, 4,  1, 16 },
{PF_DXT4,		"DXT4",	0x1908,	0x1401, 4,  1, 16 },
{PF_DXT5,		"DXT5",	0x1908,	0x1401, 4,  1, 16 },
{PF_RXGB,		"RXGB",	0x1908,	0x1401, 3,  1, 16 },
{PF_ATI1N,	"ATI1N",	0x1908,	0x1401, 1,  1,  8 },
{PF_ATI2N,	"3DC",	0x1908,	0x1401, 4,  1, 16 },
{PF_LUMINANCE,	"LUM 8",	0x1909,	0x1401, 1,  1, -1 },
{PF_LUMINANCE_16,	"LUM 16", 0x1909,	0x1401, 2,  2, -2 },
{PF_LUMINANCE_ALPHA,"LUM A",	0x190A,	0x1401, 2,  1, -2 },
{PF_UV_16,	"UV 16",	0x190A,	0x1401, 2,  1, -2 },
{PF_UV_16,	"UV 16",	0x190A,	0x1401, 2,  1, -4 },
{PF_R_16F,	"R 16f",	0x8884,	0x1406, 1,  4, -2 }, // FIXME: these NV extension, reinstall for ATI
{PF_R_32F,	"R 32f",	0x8885,	0x1406, 1,  4, -4 },
{PF_GR_32F,	"GR 32f",	0x8886,	0x1406, 2,  4, -4 },
{PF_GR_64F,	"GR 64f",	0x8887,	0x1406, 2,  4, -8 },
{PF_ABGR_64F,	"ABGR64f",0x888A,	0x1406, 4,  2, -8 },
{PF_ABGR_128F,	"ABGR128",0x888B,	0x1406, 4,  4, -16},
{PF_RGBA_GN,	"system",	0x1908,	0x1401, 4,  1, -4 },
};

size_t Image_DXTGetLinearSize( int type, int width, int height, int depth, int rgbcount )
{
	size_t BlockSize = 0;
	int block, bpp;

	// right calcualte blocksize
	block = PFDesc[type].block;
	bpp = PFDesc[type].bpp;

	if( block == 0 ) BlockSize = width * height * bpp;
	else if( block > 0 ) BlockSize = ((width + 3)/4) * ((height + 3)/4) * depth * block;
	else if( block < 0 && rgbcount > 0 ) BlockSize = width * height * depth * rgbcount;
	else BlockSize = width * height * abs( block );

	return BlockSize;
}

/*
============
FS_FileBase

Extracts the base name of a file (no path, no extension, assumes '/' as path separator)
============
*/
void _FS_FileBase( const char *in, char *out, bool kill_backwardslash )
{
	int	len, start, end;

	len = strlen( in );
	if( !len ) return;
	
	// scan backward for '.'
	end = len - 1;

	while( end && in[end] != '.' && in[end] != '/' && in[end] != '\\' )
		end--;
	
	if( in[end] != '.' )
		end = len-1; // no '.', copy to end
	else end--; // found ',', copy to left of '.'


	// scan backward for '/'
	start = len - 1;

	if( kill_backwardslash )
	{
		while( start >= 0 && in[start] != '/' && in[start] != '\\' )
			start--;

		if( start < 0 || ( in[start] != '/' && in[start] != '\\' ))
			start = 0;
		else start++;
	}
	else
	{
		// NOTE: some doomwads using backward slash as part of animation name
		// e.g. vile\1, so ignore backward slash for wads
		while ( start >= 0 && in[start] != '/' )
			start--;

		if ( start < 0 || in[start] != '/' )
			start = 0;
		else start++;
	}

	// length of new sting
	len = end - start + 1;

	// Copy partial string
	strncpy( out, &in[start], len + 1 );
	out[len] = 0;
}

void FS_FileBase( const char *in, char *out )
{
	_FS_FileBase( in, out, true );
}

bool Image_ValidSize( const char *name )
{
	if( image.width > IMAGE_MAXWIDTH || image.height > IMAGE_MAXHEIGHT || image.width <= 0 || image.height <= 0 )
		return false;
	return true;
}

// extract from buffer
_inline unsigned long BuffBigLong( const byte *buf )
{
	return (buf[0]<<24)|(buf[1]<<16)|(buf[2]<<8)|buf[3];
}

_inline unsigned long BuffLittleLong( const byte *buf )
{
	return (buf[3]<<24)|(buf[2]<<16)|(buf[1]<<8)|buf[0];
}

_inline unsigned short BuffLittleShort( const byte *buf )
{
	return (buf[1]<<8)|buf[0];
}

/*
=================
NearestPOW
=================
*/
_inline int NearestPOW( int value, bool roundDown )
{
	int	n = 1;

	if( value <= 0 ) return 1;
	while( n < value ) n <<= 1;

	if( roundDown )
	{
		if( n > value ) n >>= 1;
	}
	return n;
}

void Image_RoundDimensions( int *width, int *height )
{
	// find nearest power of two, rounding down if desired
	*width = NearestPOW( *width, 0 );
	*height = NearestPOW( *height, 0 );
}

bool Image_ForceDecompress( void )
{
	int	w, h;

	// GL_ARB_texture_compression missing, force to decompress anyway
	if(!( image.cmd_flags & IL_DDS_HARDWARE )) return true;

	// non power of two images needs resample
	// but resample code not supported compressed images
	w = image.width, h = image.height;
	Image_RoundDimensions( &w, &h );
	if( w != image.width || h != image.height )
		return true;

	// extract cubemap side from complex image
	if( image.filter != CB_HINT_NO )
		return true;

	// FIXME: load it properly with gl loader
	switch( image.type )
	{
	case PF_RXGB: return true;	// g-cont. test it with GL_COMPRESSED_RGBA_S3TC_DXT5_EXT ?
	case PF_ATI1N: return true;	// hey, how called your OpenGL extension, ATI ?
	case PF_ATI2N: return true;
	}
	return false;
}

/*
=============
Image_SetPixelFormat

update pixel format for miplevel or layer
=============
*/
void Image_SetPixelFormat( int width, int height, int depth )
{
	image.bpp = PFDesc[image.type].bpp;
	image.bpc = PFDesc[image.type].bpc;

	image.curdepth = depth;
	image.curwidth = width;
	image.curheight = height;

	image.bps = image.curwidth * image.bpp * image.bpc;
	image.SizeOfPlane = image.bps * image.curheight;
	image.SizeOfData = image.SizeOfPlane * image.curdepth;

	// NOTE: size of current miplevel or cubemap side, not total (filesize - sizeof( header ))
	image.SizeOfFile = Image_DXTGetLinearSize( image.type, width, height, depth, image.bits_count / 8 );
}


void Image_AddRGBAToPack( uint target, int level, uint imageSize, const void* data )
{
	// NOTE: just update bufer without checking for a type
	image.rgba = (byte *)realloc( image.rgba, image.ptr + imageSize );
	memcpy( image.rgba + image.ptr, data, imageSize ); // add mipmap or cubemapside

	image.size += imageSize;	// update image size
	image.ptr += imageSize;
	image.num_mips++;
}

void Image_SetPalette( const byte *pal, uint *d_table )
{
	int	i;
	byte	rgba[4];
	
	// setup palette
	switch( image.d_rendermode )
	{
	case LUMP_DECAL:
		for( i = 0; i < 256; i++ )
		{
			rgba[3] = pal[765];
			rgba[2] = pal[766];
			rgba[1] = pal[767];
			rgba[0] = i;
			d_table[i] = BuffBigLong( rgba );
		}
		break;
	case LUMP_TRANSPARENT:
		for( i = 0; i < 256; i++ )
		{
			rgba[3] = pal[i*3+0];
			rgba[2] = pal[i*3+1];
			rgba[1] = pal[i*3+2];
			rgba[0] = pal[i] == 255 ? pal[i] : 0xFF;
			d_table[i] = BuffBigLong( rgba );
		}
		break;
	case LUMP_QFONT:
		for (i = 1; i < 256; i++)
		{
			rgba[3] = pal[i*3+0];
			rgba[2] = pal[i*3+1];
			rgba[1] = pal[i*3+2];
			rgba[0] = 0xFF;
			d_table[i] = BuffBigLong( rgba );
		}
		break;
	case LUMP_NORMAL:
		for (i = 0; i < 256; i++)
		{
			rgba[3] = pal[i*3+0];
			rgba[2] = pal[i*3+1];
			rgba[1] = pal[i*3+2];
			rgba[0] = 0xFF;
			d_table[i] = BuffBigLong( rgba );
		}
		break;
	case LUMP_EXTENDED:
		for (i = 0; i < 256; i++)
		{
			rgba[3] = pal[i*4+0];
			rgba[2] = pal[i*4+1];
			rgba[1] = pal[i*4+2];
			rgba[0] = pal[i*4+3];
			d_table[i] = BuffBigLong( rgba );
		}
		break;	
	}
}

void Image_GetPaletteQ1( void )
{
	image.d_rendermode = LUMP_NORMAL;

	if(!q1palette_init)
	{
		Image_SetPalette( palette_q1, d_8toQ1table );
		d_8toQ1table[255] = 0; // 255 is transparent
		q1palette_init = true;
	}
	image.d_currentpal = d_8toQ1table;
}

void Image_GetPaletteLMP( const byte *pal, int rendermode )
{
	image.d_rendermode = rendermode;

	if( pal )
	{
		Image_SetPalette( pal, d_8to24table );
		d_8to24table[255] &= LittleLong(0xffffff);
		image.d_currentpal = d_8to24table;
	}
	else if( rendermode == LUMP_QFONT )
	{
		// quake1 base palette and font palette have some diferences
		Image_SetPalette( palette_q1, d_8to24table );
		d_8to24table[0] = 0;
		image.d_currentpal = d_8to24table;
	}
	else Image_GetPaletteQ1(); // default quake palette          
}

/*
============
Image_Copy8bitRGBA

NOTE: must call Image_GetPaletteXXX before used
============
*/
bool Image_Copy8bitRGBA( const byte *in, byte *out, int pixels )
{
	int	*iout = (int *)out;
	color32	*col;

	if( !image.d_currentpal )
	{
		LogPrintf( "Image_Copy8bitRGBA: no palette set\n" );
		return false;
	}
	if( !in )
	{
		LogPrintf( "Image_Copy8bitRGBA: no input image\n" );
		return false;
	}

	while( pixels >= 8 )
	{
		iout[0] = image.d_currentpal[in[0]];
		iout[1] = image.d_currentpal[in[1]];
		iout[2] = image.d_currentpal[in[2]];
		iout[3] = image.d_currentpal[in[3]];
		iout[4] = image.d_currentpal[in[4]];
		iout[5] = image.d_currentpal[in[5]];
		iout[6] = image.d_currentpal[in[6]];
		iout[7] = image.d_currentpal[in[7]];

		col = (color32 *)iout;
		if( col->r != col->g || col->g != col->b )
			image.flags |= IMAGE_HAS_COLOR;

		in += 8;
		iout += 8;
		pixels -= 8;
	}
	if( pixels & 4 )
	{
		iout[0] = image.d_currentpal[in[0]];
		iout[1] = image.d_currentpal[in[1]];
		iout[2] = image.d_currentpal[in[2]];
		iout[3] = image.d_currentpal[in[3]];
		in += 4;
		iout += 4;
	}
	if( pixels & 2 )
	{
		iout[0] = image.d_currentpal[in[0]];
		iout[1] = image.d_currentpal[in[1]];
		in += 2;
		iout += 2;
	}
	if( pixels & 1 ) // last byte
		iout[0] = image.d_currentpal[in[0]];

	image.type = PF_RGBA_32;	// update image type;
	return true;
}

/*
====================
Image_GetBitsFromMask
====================
*/
void Image_GetBitsFromMask( uint Mask, uint *ShiftLeft, uint *ShiftRight )
{
	uint Temp, i;

	if( Mask == 0 )
	{
		*ShiftLeft = *ShiftRight = 0;
		return;
	}

	Temp = Mask;
	for (i = 0; i < 32; i++, Temp >>= 1)
	{
		if (Temp & 1) break;
	}
	*ShiftRight = i;

	// Temp is preserved, so use it again:
	for (i = 0; i < 8; i++, Temp >>= 1)
	{
		if(!(Temp & 1)) break;
	}
	*ShiftLeft = 8 - i;
}


bool Image_DecompressPal8( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	byte	*fin, *fout;
	int	size; 

	if( !data ) return false;
	fin = (byte *)data;

	size = width * height * image.curdepth * 4;
	image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
	fout = image.tempbuffer;

	switch( PFDesc[intformat].format )
	{
	case PF_INDEXED_24:
		if( image.flags & IMAGE_HAS_ALPHA )
		{
			if( image.flags & IMAGE_COLORINDEX )
				Image_GetPaletteLMP( image.palette, LUMP_DECAL ); 
			else Image_GetPaletteLMP( image.palette, LUMP_TRANSPARENT ); 
		}
		else Image_GetPaletteLMP( image.palette, LUMP_NORMAL );
		// intentional falltrough
	case PF_INDEXED_32:
		if( !image.d_currentpal ) image.d_currentpal = ( uint *)image.palette;
		if( !Image_Copy8bitRGBA( fin, fout, width * height )) return false;
		break;
	}

	Image_AddRGBAToPack( target, level, size, fout );
	return true;
}

bool Image_DecompressRGBA( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	byte	*fin, *fout;
	int	i, size; 
	color16	*col;

	if( !data ) return false;
	fin = (byte *)data;

	size = width * height * image.curdepth * 4;
	image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
	fout = image.tempbuffer;

	switch( PFDesc[intformat].format )
	{
	case PF_RGB_16:
		for( i = 0, col = (color16 *)fin; i < width * height; i++ )
		{
			fout[(i<<2)+0] = col->r << 3;
			fout[(i<<2)+1] = col->g << 2;
			fout[(i<<2)+2] = col->b << 3;
			fout[(i<<2)+3] = 255;
			col += sizeof( color16 );
		}
		break;	
	case PF_RGB_24:
		for (i = 0; i < width * height; i++ )
		{
			fout[(i<<2)+0] = fin[i*3+0];
			fout[(i<<2)+1] = fin[i*3+1];
			fout[(i<<2)+2] = fin[i*3+2];
			fout[(i<<2)+3] = 255;
		}
		break;
	case PF_BGR_24:
		for (i = 0; i < width * height; i++ )
		{
			fout[(i<<2)+0] = fin[i*3+2];
			fout[(i<<2)+1] = fin[i*3+1];
			fout[(i<<2)+2] = fin[i*3+0];
			fout[(i<<2)+3] = 255;
		}
		break;
	case PF_RGBA_GN:
	case PF_RGBA_32:
		memcpy( fout, fin, size );
		break;
	case PF_BGRA_32:
	case PF_ABGR_64:
		for( i = 0; i < width * height; i++ )
		{
			fout[i*4+0] = fin[i*4+2];
			fout[i*4+1] = fin[i*4+1];
			fout[i*4+2] = fin[i*4+0];
			fout[i*4+3] = fin[i*4+3];
		}
		break;
	default: return false;
	}

	Image_AddRGBAToPack( target, level, size, fout );
	return true;
}

bool Image_DecompressARGB( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	uint	ReadI = 0, TempBpp;
	uint	RedL, RedR, GreenL, GreenR, BlueL, BlueR, AlphaL, AlphaR;
	uint	r_bitmask, g_bitmask, b_bitmask, a_bitmask;
	int	i, w, h, size;
	byte	*fin, *fout;

	if( !data ) return false;

	w = width;
	h = height;
	fin = (byte *)data;
	size = width * height * image.curdepth * 4;
	image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
	fout = image.tempbuffer;

	if( PFDesc[intformat].format == PF_LUMINANCE_16 )
	{
		memcpy( fout, data, image.SizeOfData);
	}
	else if( image.palette )
	{
		byte *pal = image.palette; //copy ptr
		r_bitmask	= BuffLittleLong( pal ); pal += 4;
		g_bitmask = BuffLittleLong( pal ); pal += 4;
		b_bitmask = BuffLittleLong( pal ); pal += 4;
		a_bitmask = BuffLittleLong( pal ); pal += 4;
	}
	else return false; // rgba mask unset

	Image_GetBitsFromMask( r_bitmask, &RedL, &RedR );
	Image_GetBitsFromMask( g_bitmask, &GreenL, &GreenR );
	Image_GetBitsFromMask( b_bitmask, &BlueL, &BlueR );
	Image_GetBitsFromMask( a_bitmask, &AlphaL, &AlphaR );
          
	TempBpp = image.bits_count / 8;

	for( i = 0; i < image.SizeOfData; i += image.bpp )
	{
		// TODO: This is SLOOOW...
		// but the old version crashed in release build under
		// winxp (and xp is right to stop this code - I always
		// wondered that it worked the old way at all)
		if( image.SizeOfData - i < 4 )
		{
			// less than 4 byte to write?
			if( TempBpp == 1 ) ReadI = *((byte*) fin );
			else if( TempBpp == 2 ) ReadI = BuffLittleShort( fin );
			else if( TempBpp == 3 ) ReadI = BuffLittleLong( fin );
		}
		else ReadI = BuffLittleLong( fin );
		fin += TempBpp;
		fout[i] = ((ReadI & r_bitmask)>> RedR) << RedL;

		if( image.bpp >= 3 )
		{
			fout[i+1] = ((ReadI & g_bitmask) >> GreenR) << GreenL;
			fout[i+2] = ((ReadI & b_bitmask) >> BlueR) << BlueL;
			if( image.bpp == 4 )
			{
				fout[i+3] = ((ReadI & a_bitmask) >> AlphaR) << AlphaL;
				if( AlphaL >= 7 ) fout[i+3] = fout[i+3] ? 0xFF : 0x00;
				else if( AlphaL >= 4 ) fout[i+3] = fout[i+3]|(fout[i+3] >> 4);
			}
		}
		else if( image.bpp == 2 )
		{
			fout[i+1] = ((ReadI & a_bitmask) >> AlphaR) << AlphaL;
			if( AlphaL >= 7 ) fout[i+1] = fout[i+1] ? 0xFF : 0x00;
			else if( AlphaL >= 4 ) fout[i+1] = fout[i+1]|(fout[i+3] >> 4);
		}
	}

	Image_AddRGBAToPack( target, level, size, fout );
	return true;
}


/*
====================
Image_DXTReadColors

read colors from dxt image
====================
*/
void Image_DXTReadColors( const byte* data, color32* out )
{
	byte r0, g0, b0, r1, g1, b1;

	b0 = data[0] & 0x1F;
	g0 = ((data[0] & 0xE0) >> 5) | ((data[1] & 0x7) << 3);
	r0 = (data[1] & 0xF8) >> 3;

	b1 = data[2] & 0x1F;
	g1 = ((data[2] & 0xE0) >> 5) | ((data[3] & 0x7) << 3);
	r1 = (data[3] & 0xF8) >> 3;

	out[0].r = r0<<3;
	out[0].g = g0<<2;
	out[0].b = b0<<3;

	out[1].r = r1<<3;
	out[1].g = g1<<2;
	out[1].b = b1<<3;
}

/*
====================
Image_DXTReadColor

read one color from dxt image
====================
*/
void Image_DXTReadColor( word data, color32* out )
{
	byte r, g, b;

	b = data & 0x1f;
	g = (data & 0x7E0) >>5;
	r = (data & 0xF800)>>11;

	out->r = r << 3;
	out->g = g << 2;
	out->b = b << 3;
}

void Image_CorrectPreMult( uint *data, int datasize )
{
	int	i;

	for( i = 0; i < datasize; i += 4 )
	{
		if( data[i+3] != 0 ) // don't divide by 0.
		{	
			data[i+0] = (byte)(((uint)data[i+0]<<8) / data[i+3]);
			data[i+1] = (byte)(((uint)data[i+1]<<8) / data[i+3]);
			data[i+2] = (byte)(((uint)data[i+2]<<8) / data[i+3]);
		}
	}
}

bool Image_DecompressDXT( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	color32	colours[4], *col;
	color16	*color_0, *color_1;
	word	sAlpha, sColor0, sColor1;
	uint	bits, bitmask, Offset, size;
	byte	alphas[8], *alpha, *alphamask; 
	int	w, h, x, y, z, i, j, k, Select; 
	bool	has_alpha = false;
	byte	*fin, *fout;

	if( !data ) return false;
	fin = (byte *)data;

	w = width;
	h = height;

	size = width * height * image.curdepth * 4;
	image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
	fout = image.tempbuffer;
	
	switch( PFDesc[intformat].format )
	{
	case PF_DXT1:
		colours[0].a = 0xFF;
		colours[1].a = 0xFF;
		colours[2].a = 0xFF;

		for( z = 0; z < image.curdepth; z++ )
		{
			for( y = 0; y < h; y += 4 )
			{
				for( x = 0; x < w; x += 4 )
				{
					sColor0 = *((word*)fin);
					sColor0 = LittleShort(sColor0);
					sColor1 = *((word*)(fin + 2));
					sColor1 = LittleShort(sColor1);

					Image_DXTReadColor(sColor0, colours);
					Image_DXTReadColor(sColor1, colours + 1);

					bitmask = ((uint*)fin)[1];
					bitmask = LittleLong( bitmask );
					fin += 8;

					if (sColor0 > sColor1)
					{
						// four-color block: derive the other two colors.
						// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
						// These 2-bit codes correspond to the 2-bit fields 
						// stored in the 64-bit block.
						colours[2].b = (2 * colours[0].b + colours[1].b + 1) / 3;
						colours[2].g = (2 * colours[0].g + colours[1].g + 1) / 3;
						colours[2].r = (2 * colours[0].r + colours[1].r + 1) / 3;
						colours[3].b = (colours[0].b + 2 * colours[1].b + 1) / 3;
						colours[3].g = (colours[0].g + 2 * colours[1].g + 1) / 3;
						colours[3].r = (colours[0].r + 2 * colours[1].r + 1) / 3;
						colours[3].a = 0xFF;
					}
					else
					{ 
						// three-color block: derive the other color.
						// 00 = color_0,  01 = color_1,  10 = color_2,
						// 11 = transparent.
						// These 2-bit codes correspond to the 2-bit fields 
						// stored in the 64-bit block. 
						colours[2].b = (colours[0].b + colours[1].b) / 2;
						colours[2].g = (colours[0].g + colours[1].g) / 2;
						colours[2].r = (colours[0].r + colours[1].r) / 2;
						colours[3].b = (colours[0].b + 2 * colours[1].b + 1) / 3;
						colours[3].g = (colours[0].g + 2 * colours[1].g + 1) / 3;
						colours[3].r = (colours[0].r + 2 * colours[1].r + 1) / 3;
						colours[3].a = 0x00;
					}
					for( j = 0, k = 0; j < 4; j++ )
					{
						for( i = 0; i < 4; i++, k++ )
						{
							Select = (bitmask & (0x03 << k*2)) >> k*2;
							col = &colours[Select];

							if (((x + i) < w) && ((y + j) < h))
							{
								uint ofs = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp;
								fout[ofs+0] = col->r;
								fout[ofs+1] = col->g;
								fout[ofs+2] = col->b;
								fout[ofs+3] = col->a;
								if( col->a == 0 ) has_alpha = true;
							}
						}
					}
				}
			}
		}
		break;
	case PF_DXT2:
		image.flags |= IMAGE_PREMULT;
		// intentional fallthrough
	case PF_DXT3:
		for( z = 0; z < image.curdepth; z++ )
		{
			for( y = 0; y < h; y += 4 )
			{
				for( x = 0; x < w; x += 4 )
				{
					alpha = fin;
					fin += 8;
					Image_DXTReadColors( fin, colours );
					bitmask = ((uint*)fin)[1];
					bitmask = LittleLong( bitmask );
					fin += 8;

					// four-color block: derive the other two colors.    
					// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
					// These 2-bit codes correspond to the 2-bit fields 
					// stored in the 64-bit block.
					colours[2].b = (2 * colours[0].b + colours[1].b + 1) / 3;
					colours[2].g = (2 * colours[0].g + colours[1].g + 1) / 3;
					colours[2].r = (2 * colours[0].r + colours[1].r + 1) / 3;
					colours[3].b = (colours[0].b + 2 * colours[1].b + 1) / 3;
					colours[3].g = (colours[0].g + 2 * colours[1].g + 1) / 3;
					colours[3].r = (colours[0].r + 2 * colours[1].r + 1) / 3;

					k = 0;
					for( j = 0; j < 4; j++ )
					{
						for( i = 0; i < 4; i++, k++ )
						{
							Select = (bitmask & (0x03 << k*2)) >> k*2;
							col = &colours[Select];
							if(((x + i) < w) && ((y + j) < h))
							{
								Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp;
								fout[Offset + 0] = col->r;
								fout[Offset + 1] = col->g;
								fout[Offset + 2] = col->b;
							}
						}
					}
					for( j = 0; j < 4; j++ )
					{
						sAlpha = alpha[2*j] + 256*alpha[2*j+1];
						for( i = 0; i < 4; i++ )
						{
							if(((x + i) < w) && ((y + j) < h))
							{
								Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp + 3;
								fout[Offset] = sAlpha & 0x0F;
								fout[Offset] = fout[Offset] | (fout[Offset]<<4);
								if(sAlpha == 0) has_alpha = true;
							}
							sAlpha >>= 4;
						}
					}
				}
			}
		}
		break;
	case PF_DXT4:
		image.flags |= IMAGE_PREMULT;
		// intentional fallthrough
	case PF_DXT5:
		for( z = 0; z < image.curdepth; z++ )
		{
			for( y = 0; y < h; y += 4 )
			{
				for( x = 0; x < w; x += 4 )
				{
					if( y >= h || x >= w ) break;
					alphas[0] = fin[0];
					alphas[1] = fin[1];
					alphamask = fin + 2;
					fin += 8;

					Image_DXTReadColors(fin, colours);
					bitmask = ((uint*)fin)[1];
					bitmask = LittleLong(bitmask);
					fin += 8;

					// four-color block: derive the other two colors.    
					// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
					// these 2-bit codes correspond to the 2-bit fields 
					// stored in the 64-bit block.
					colours[2].b = (2 * colours[0].b + colours[1].b + 1) / 3;
					colours[2].g = (2 * colours[0].g + colours[1].g + 1) / 3;
					colours[2].r = (2 * colours[0].r + colours[1].r + 1) / 3;
					colours[3].b = (colours[0].b + 2 * colours[1].b + 1) / 3;
					colours[3].g = (colours[0].g + 2 * colours[1].g + 1) / 3;
					colours[3].r = (colours[0].r + 2 * colours[1].r + 1) / 3;

					k = 0;
					for( j = 0; j < 4; j++ )
					{
						for( i = 0; i < 4; i++, k++ )
						{
							Select = (bitmask & (0x03 << k*2)) >> k*2;
							col = &colours[Select];
							// only put pixels out < width or height
							if(((x + i) < w) && ((y + j) < h))
							{
								Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp;
								fout[Offset+0] = col->r;
								fout[Offset+1] = col->g;
								fout[Offset+2] = col->b;
							}
						}
					}
					// 8-alpha or 6-alpha block?    
					if( alphas[0] > alphas[1] )
					{    
						// 8-alpha block:  derive the other six alphas.    
						// bit code 000 = alpha_0, 001 = alpha_1, others are interpolated.
						alphas[2] = (6 * alphas[0] + 1 * alphas[1] + 3) / 7; // bit code 010
						alphas[3] = (5 * alphas[0] + 2 * alphas[1] + 3) / 7; // bit code 011
						alphas[4] = (4 * alphas[0] + 3 * alphas[1] + 3) / 7; // bit code 100
						alphas[5] = (3 * alphas[0] + 4 * alphas[1] + 3) / 7; // bit code 101
						alphas[6] = (2 * alphas[0] + 5 * alphas[1] + 3) / 7; // bit code 110
						alphas[7] = (1 * alphas[0] + 6 * alphas[1] + 3) / 7; // bit code 111
					}
					else
					{
						// 6-alpha block.
						// bit code 000 = alpha_0, 001 = alpha_1, others are interpolated.
						alphas[2] = (4 * alphas[0] + 1 * alphas[1] + 2) / 5; // bit code 010
						alphas[3] = (3 * alphas[0] + 2 * alphas[1] + 2) / 5; // bit code 011
						alphas[4] = (2 * alphas[0] + 3 * alphas[1] + 2) / 5; // bit code 100
						alphas[5] = (1 * alphas[0] + 4 * alphas[1] + 2) / 5; // bit code 101
						alphas[6] = 0x00;				// bit code 110
						alphas[7] = 0xFF;				// bit code 111
					}
					// NOTE: Have to separate the next two loops,
					// it operates on a 6-byte system.

					// first three bytes
					bits = (alphamask[0]) | (alphamask[1] << 8) | (alphamask[2] << 16);
					for( j = 0; j < 2; j++ )
					{
						for( i = 0; i < 4; i++ )
						{
							// only put pixels out < width or height
							if(((x + i) < w) && ((y + j) < h))
							{
								Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp + 3;
								fout[Offset] = alphas[bits & 0x07];
							}
							bits >>= 3;
						}
					}
					// last three bytes
					bits = (alphamask[3]) | (alphamask[4] << 8) | (alphamask[5] << 16);
					for( j = 2; j < 4; j++ )
					{
						for( i = 0; i < 4; i++ )
						{
							// only put pixels out < width or height
							if (((x + i) < w) && ((y + j) < h))
							{
								Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp + 3;
								fout[Offset] = alphas[bits & 0x07];
								if( bits & 0x07 ) has_alpha = true; 
							}
							bits >>= 3;
						}
					}
				}
			}
		}
		break;
	case PF_RXGB:
		for( z = 0; z < image.curdepth; z++ )
		{
			for( y = 0; y < h; y += 4 )
			{
				for( x = 0; x < w; x += 4 )
				{
					if( y >= h || x >= w ) break;
					alphas[0] = fin[0];
					alphas[1] = fin[1];
					alphamask = fin + 2;
					fin += 8;

					color_0 = ((color16*)fin);
					color_1 = ((color16*)(fin+2));
					bitmask = ((uint*)fin)[1];
					fin += 8;

					colours[0].r = color_0->r << 3;
					colours[0].g = color_0->g << 2;
					colours[0].b = color_0->b << 3;
					colours[0].a = 0xFF;
					colours[1].r = color_1->r << 3;
					colours[1].g = color_1->g << 2;
					colours[1].b = color_1->b << 3;
					colours[1].a = 0xFF;

					// four-color block: derive the other two colors.    
					// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
					// these 2-bit codes correspond to the 2-bit fields 
					// stored in the 64-bit block.
					colours[2].b = (2 * colours[0].b + colours[1].b + 1) / 3;
					colours[2].g = (2 * colours[0].g + colours[1].g + 1) / 3;
					colours[2].r = (2 * colours[0].r + colours[1].r + 1) / 3;
					colours[2].a = 0xFF;
					colours[3].b = (colours[0].b + 2 * colours[1].b + 1) / 3;
					colours[3].g = (colours[0].g + 2 * colours[1].g + 1) / 3;
					colours[3].r = (colours[0].r + 2 * colours[1].r + 1) / 3;
					colours[3].a = 0xFF;

				k = 0;
				for( j = 0; j < 4; j++ )
				{
					for( i = 0; i < 4; i++, k++ )
					{
						Select = (bitmask & (0x03 << k*2)) >> k*2;
						col = &colours[Select];

						// only put pixels out < width or height
						if(((x + i) < w) && ((y + j) < h))
						{
							Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp;
							fout[Offset + 0] = col->r;
							fout[Offset + 1] = col->g;
							fout[Offset + 2] = col->b;
						}
					}
				}

				// 8-alpha or 6-alpha block?    
				if (alphas[0] > alphas[1])
				{    
					// 8-alpha block:  derive the other six alphas.    
					// bit code 000 = alpha_0, 001 = alpha_1, others are interpolated.
					alphas[2] = (6 * alphas[0] + 1 * alphas[1] + 3) / 7; // bit code 010
					alphas[3] = (5 * alphas[0] + 2 * alphas[1] + 3) / 7; // bit code 011
					alphas[4] = (4 * alphas[0] + 3 * alphas[1] + 3) / 7; // bit code 100
					alphas[5] = (3 * alphas[0] + 4 * alphas[1] + 3) / 7; // bit code 101
					alphas[6] = (2 * alphas[0] + 5 * alphas[1] + 3) / 7; // bit code 110
					alphas[7] = (1 * alphas[0] + 6 * alphas[1] + 3) / 7; // bit code 111
				}
				else
				{
					// 6-alpha block.
					// bit code 000 = alpha_0, 001 = alpha_1, others are interpolated.
					alphas[2] = (4 * alphas[0] + 1 * alphas[1] + 2) / 5; // bit code 010
					alphas[3] = (3 * alphas[0] + 2 * alphas[1] + 2) / 5; // bit code 011
					alphas[4] = (2 * alphas[0] + 3 * alphas[1] + 2) / 5; // bit code 100
					alphas[5] = (1 * alphas[0] + 4 * alphas[1] + 2) / 5; // bit code 101
					alphas[6] = 0x00;				// bit code 110
					alphas[7] = 0xFF;				// bit code 111
				}

				// NOTE: Have to separate the next two loops,
				// it operates on a 6-byte system.
				// first three bytes

				bits = *((int*)alphamask);
				for( j = 0; j < 2; j++ )
				{
					for( i = 0; i < 4; i++ )
					{
						// only put pixels out < width or height
						if(((x + i) < w) && ((y + j) < h))
						{
							Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp;
							fout[Offset] = alphas[bits & 0x07];
						}
						bits >>= 3;
					}
				}

				// last three bytes
				bits = *((int*)&alphamask[3]);

				for( j = 2; j < 4; j++ )
				{
					for( i = 0; i < 4; i++ )
					{
						// only put pixels out < width or height
						if(((x + i) < w) && ((y + j) < h))
						{
							Offset = z * image.SizeOfPlane + (y + j) * image.bps + (x + i) * image.bpp;
							fout[Offset] = alphas[bits & 0x07];
						}
						bits >>= 3;
					}
				}
			}
		}
	}
	default: return false;
	}

	// make some post operations
	if( has_alpha ) image.flags |= IMAGE_HAS_ALPHA;
	if( image.flags & IMAGE_PREMULT )
	{
		Image_CorrectPreMult((uint *)fout, size );
		image.flags &= ~IMAGE_PREMULT;
	}

	Image_AddRGBAToPack( target, level, size, fout );
	return true;
}


bool Image_DecompressATI( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	int	x, y, z, i, j, k, t1, t2, size;
	byte	Colours[8], XColours[8], YColours[8];
	uint	bitmask, bitmask2, CurrOffset, Offset = 0;
	byte	*fin, *fin2, *fout;
	bool	has_alpha = false;

	if( !data ) return false;
	fin = (byte *)data;

	size = width * height * image.curdepth * 4;
	image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
	fout = image.tempbuffer;

	switch( PFDesc[intformat].format )
	{
	case PF_ATI1N:
		image.flags &= ~IMAGE_HAS_COLOR;
		image.flags |= IMAGE_HAS_ALPHA;
		for( z = 0; z < image.curdepth; z++ )
		{
			for( y = 0; y < height; y += 4 )
			{
				for( x = 0; x < width; x += 4 )
				{
					// read palette
					t1 = Colours[0] = fin[0];
					t2 = Colours[1] = fin[1];
					fin += 2;

					if( t1 > t2 )
					{
						for( i = 2; i < 8; i++ )
							Colours[i] = t1 + ((t2 - t1) * (i - 1)) / 7;
					}
					else
					{
						for( i = 2; i < 6; i++ )
							Colours[i] = t1 + ((t2 - t1) * (i - 1)) / 5;
						Colours[6] = 0;
						Colours[7] = 0xFF;
					}

					// decompress pixel data
					CurrOffset = Offset;
					for( k = 0; k < 4; k += 2 )
					{
						// first three bytes
						bitmask = ((uint)(fin[0]) << 0) | ((uint)(fin[1]) << 8) | ((uint)(fin[2]) << 16);

						for( j = 0; j < 2; j++ )
						{
							// only put pixels out < height
							if((y + k + j) < height )
							{
								for( i = 0; i < 4; i++ )
								{
									// only put pixels out < width
									if((x + i) < width )
									{
										t1 = CurrOffset + (x + i);
										fout[t1*4+0] = Colours[bitmask & 0x07];
										fout[t1*4+1] = Colours[bitmask & 0x07];
										fout[t1*4+2] = Colours[bitmask & 0x07];
										fout[t1*4+3] = Colours[bitmask & 0x07];
									}
									bitmask >>= 3;
								}
								CurrOffset += image.bps;
							}
						}
						fin += 3;
					}
				}
				Offset += image.bps * 4;
			}
		}
		break;
	case PF_ATI2N:
		image.flags |= IMAGE_HAS_COLOR;
		image.flags &= ~IMAGE_HAS_ALPHA;
		for( z = 0; z < image.curdepth; z++ )
		{
			for( y = 0; y < height; y += 4 )
			{
				for( x = 0; x < width; x += 4 )
				{
					fin2 = fin + 8;

					// read Y palette
					t1 = YColours[0] = fin[0];
					t2 = YColours[1] = fin[1];
					fin += 2;

					if( t1 > t2 )
					{
						for( i = 2; i < 8; i++ )
							YColours[i] = t1 + ((t2 - t1) * (i - 1)) / 7;
					}
					else
					{
						for( i = 2; i < 6; i++ )
							YColours[i] = t1 + ((t2 - t1) * (i - 1)) / 5;
						YColours[6] = 0;
						YColours[7] = 0xFF;
					}

					// read X palette
					t1 = XColours[0] = fin2[0];
					t2 = XColours[1] = fin2[1];
					fin2 += 2;

					if( t1 > t2 )
					{
						for( i = 2; i < 8; ++i )
							XColours[i] = t1 + ((t2 - t1) * (i - 1)) / 7;
					}
					else
					{
						for( i = 2; i < 6; ++i )
							XColours[i] = t1 + ((t2 - t1) * (i - 1)) / 5;
						XColours[6] = 0;
						XColours[7] = 0xFF;
					}
					// decompress pixel data
					CurrOffset = Offset;

					for( k = 0; k < 4; k += 2 )
					{
						// first three bytes
						bitmask = ((uint)(fin[0]) << 0) | ((uint)(fin[1]) << 8) | ((uint)(fin[2]) << 16);
						bitmask2 = ((uint)(fin2[0]) << 0) | ((uint)(fin2[1]) << 8) | ((uint)(fin2[2]) << 16);

						for( j = 0; j < 2; j++ )
						{
							// only put pixels out < height
							if((y + k + j) < height )
							{
								for( i = 0; i < 4; i++ )
								{
									// only put pixels out < width
									if((x + i) < width )
									{
										int t, tx, ty;

										t1 = CurrOffset + (x + i) * 4;
										fout[t1+1] = ty = YColours[bitmask & 0x07];
										fout[t1+0] = tx = XColours[bitmask2 & 0x07];

										// calculate b (z) component ((r/255)^2 + (g/255)^2 + (b/255)^2 = 1
										t = 127 * 128 - (tx - 127) * (tx - 128) - (ty - 127) * (ty - 128);

										if( t > 0 ) fout[t1+2] = (byte)(sqrt( (double)t ) + 128);
										else fout[t1+2] = 0x7F;
										fout[t1+3] = 0xFF;
									}
									bitmask >>= 3;
									bitmask2 >>= 3;
								}
								CurrOffset += image.bps;
							}
						}
						fin += 3;
						fin2 += 3;
					}
					// skip bytes that were read via fin2
					fin += 8;
				}
				Offset += image.bps * 4;
			}
		}
		break;
	default: return false;
	}

	// make some post operations
	Image_AddRGBAToPack( target, level, size, fout );
	return true;
}

bool Image_DecompressDUDV( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	byte	*fin, *fout;
	int	i, size; 
	short	*col;

	if( !data ) return false;
	fin = (byte *)data;

	size = width * height * image.curdepth * 4;
	image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
	fout = image.tempbuffer;

	switch( PFDesc[intformat].format )
	{
	case PF_UV_16:
		for( i = 0, col = (short *)fin; i < width * height; i++, col += sizeof( short ))
		{
			fout[(i<<2)+0] = col[0];
			fout[(i<<2)+1] = col[1];
			fout[(i<<2)+2] = 0;
			fout[(i<<2)+3] = 0;
		}
		break;
	case PF_UV_32:
		memcpy( fout, fin, size );	// nothing to process
		break;
	}

	Image_AddRGBAToPack( target, level, size, fout );
	return true;
}

/*
====================
Image_ShortToFloat
====================
*/
uint Image_ShortToFloat( word y )
{
	int s = (y >> 15) & 0x00000001;
	int e = (y >> 10) & 0x0000001f;
	int m =  y & 0x000003ff;

	// float: 1 sign bit, 8 exponent bits, 23 mantissa bits
	// half: 1 sign bit, 5 exponent bits, 10 mantissa bits

	if( e == 0 )
	{
		if( m == 0 ) return s << 31; // Plus or minus zero
		else // denormalized number -- renormalize it
		{
			while(!(m & 0x00000400))
			{
				m <<= 1;
				e -=  1;
			}
			e += 1;
			m &= ~0x00000400;
		}
	}
	else if( e == 31 )
	{
		if( m == 0 ) return (s << 31) | 0x7f800000; // positive or negative infinity
		else return (s << 31) | 0x7f800000 | (m << 13); // NAN - preserve sign and significand bits
	}

	// normalized number
	e = e + (127 - 15);
	m = m << 13;
	return (s << 31) | (e << 23) | m; // assemble s, e and m.
}

bool Image_DecompressFloat( uint target, int level, int intformat, uint width, uint height, uint imageSize, const void* data )
{
	uint	floatformat = 0;
	uint	i, size = 0;
	uint	pixformat = PFDesc[intformat].format;
	word	*src = (word *)data;
	uint	*dest;

	if( !src ) return false;

	switch( pixformat )
	{
	case PF_R_16F:
	case PF_GR_32F:
	case PF_ABGR_64F:
		size = width * height * image.curdepth * image.bpp;
		image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
		dest = (uint *)image.tempbuffer;
		for( i = 0; i < size; i++, dest++, src++ )
			*dest = Image_ShortToFloat( *src );
		break;
	case PF_R_32F:
	case PF_GR_64F:
	case PF_ABGR_128F:
		size = image.SizeOfData;
		image.tempbuffer = (byte *)realloc( image.tempbuffer, size );
		dest = (uint *)image.tempbuffer;
		memcpy( dest, data, image.SizeOfData );
		break;
	default: return false;
	}
	Image_AddRGBAToPack( target, level, size, dest );
	return true;
}

void Image_DecompressDDS( const byte *buffer, uint target )
{
	int	i, size = 0;
	int	w = image.curwidth;
	int	h = image.curheight;
	int	d = image.curdepth;

	// filter by cubemap side
	if( image.filter != CB_HINT_NO && image.filter != target )
		return;

	switch( image.type )
	{
	case PF_INDEXED_24:
	case PF_INDEXED_32: image.decompress = Image_DecompressPal8; break;
	case PF_RGBA_32: 
	case PF_BGRA_32: image.decompress = Image_DecompressRGBA; break;
	case PF_ARGB_32: image.decompress = Image_DecompressARGB; break;
	case PF_ABGR_64: 
	case PF_RGB_24:
	case PF_BGR_24: 
	case PF_RGB_16: image.decompress = Image_DecompressRGBA; break;
	case PF_DXT1:
	case PF_DXT2:
	case PF_DXT3:
	case PF_DXT4:
	case PF_DXT5:
	case PF_RXGB: image.decompress = Image_DecompressDXT; break;
	case PF_ATI1N:
	case PF_ATI2N: image.decompress = Image_DecompressATI; break;
	case PF_LUMINANCE:
	case PF_LUMINANCE_16:
	case PF_LUMINANCE_ALPHA: image.decompress = Image_DecompressARGB; break;
	case PF_UV_16:
	case PF_UV_32: image.decompress = Image_DecompressDUDV; break;
	case PF_R_16F:
	case PF_R_32F:
	case PF_GR_32F:
	case PF_GR_64F:
	case PF_ABGR_64F:
	case PF_ABGR_128F: image.decompress = Image_DecompressFloat; break;
	case PF_RGBA_GN: image.decompress = Image_DecompressRGBA; break;
	default: LogPrintf( "Image_DecompressDDS: unknown image format\n" );
	}

	for( i = 0; i < image.cur_mips; i++ )
	{
		Image_SetPixelFormat( w, h, d );
		size = image.SizeOfFile;

		if(!image.decompress( target, i, image.type, w, h, size, buffer ))
			break; // there were errors
		w = (w+1)>>1, h = (h+1)>>1, d = (d+1)>>1; // calc size of next mip
		buffer += size;
	}
}
































// VTF->DXT supply conversion structures
typedef struct
{
	long	ofs;		// buffer + ofs
	size_t	size;		// map size
} vlayer_t;

typedef struct
{
	vlayer_t	layers[512];	// max frames or layers
	int	numlayers;
} vmip_t;

typedef struct
{
	vmip_t	mips[512];	// max frames or layers	
	int	nummips;		// or cubemap counts
} vside_t;

typedef struct
{
	vside_t	sides[CB_FACECOUNT];// 6 cubemap sides and one envmap
	int	numSides;		// must be equal 1 or 7
} vtex_t;

// NOTE: not-in list VTF formats never used in games based on Source Engine
pixformat_t Image_VTFFormat( vtf_format_t srcFormat )
{
	switch( srcFormat )
	{
	case VTF_DXT1:
	case VTF_DXT1_ONEBITALPHA:
		return PF_DXT1;
	case VTF_DXT3:
		return PF_DXT3;
	case VTF_DXT5:
		return PF_DXT5;
	case VTF_RGBA16161616F:
		return PF_ABGR_64F;
	case VTF_BGR888:
		return PF_BGR_24;
	case VTF_UVWQ8888:
		return PF_UV_32;
	case VTF_BGRA8888:
		return PF_BGRA_32;
	case VTF_UV88:
		return PF_UV_16;
	case VTF_RGBA8888:
		return PF_RGBA_32;
	case VTF_RGB888:
		return PF_RGB_24;
	case VTF_UNKNOWN:
		return (pixformat_t)VTF_UNKNOWN;
	default: return PF_UNKNOWN;
	}
} 


/*
================
Image_VTFCalcLowResSize

lowres image hasn't mip-levels, frames or cubemap sides
typically params: 16x16 DXT1 but can be missing
================
*/
size_t Image_VTFCalcLowResSize( vtf_t *hdr )
{
	size_t	buffsize = 0;
	int	w, h, format;

	format = Image_VTFFormat( LittleLong( hdr->lowResImageFormat ));

	// missing lowRes image for -1 value
	if( format != VTF_UNKNOWN )
	{
		w = LittleShort( hdr->lowResImageWidth );
		h = LittleShort( hdr->lowResImageHeight );
		buffsize = Image_DXTGetLinearSize( format, w, h, 1, 0 );
	}
	return buffsize;
}

/*
================
Image_VTFCalcMipmapSize

stupid idea - last miplevel (1x1) put at begin of buffer
or DX8 format requries it, i'm don't know...
================
*/
size_t Image_VTFCalcMipmapSize( vtf_t *hdr, int mipNum ) 
{
	size_t	buffsize = 0;
	int	w, h, mipsize;

	w = max( 1, LittleShort(hdr->width)>>mipNum );
	h = max( 1, LittleShort(hdr->height)>>mipNum );
	mipsize = Image_DXTGetLinearSize( image.type, w, h, 1, 0 );
	return mipsize;
}


/*
================
Image_VTFCalcImageSize

main image size without header and lowres
================
*/
size_t Image_VTFCalcImageSize( vtf_t *hdr, bool oldformat ) 
{
	size_t	buffsize = 0;
	int	i, numSides = 1;

	if( image.flags & IMAGE_CUBEMAP ) numSides = (oldformat) ? 6 : CB_FACECOUNT;
	for( i = 0; i < image.num_mips; i++ )
		buffsize += Image_VTFCalcMipmapSize( hdr, i ) * image.depth * numSides;
	return buffsize;
}

/*
================
Image_VTFSwapBuffer

VTF: <format>
header:	vtf_t
lowResImage[lowResSize]
mipmaps
  layers (frames)
    sides

DDS: <format>
header:	dds_t
sides
  mipmaps
    layers 
================
*/
void Image_VTFSwapBuffer( vtf_t *hdr, const byte *input, size_t input_size, bool oldformat )
{
	int	numSides = (image.flags & IMAGE_CUBEMAP) ? oldformat ? 6 : CB_FACECOUNT : 1; 
	vtex_t	*texture = (vtex_t	*)malloc( sizeof( vtex_t ));
	bool	ignore_mips = (image.cmd_flags & IL_IGNORE_MIPS); 
	uint	i, j, k, out_size = 0;
	byte	*src, *dst;

	// output size can't be more than input size
	image.tempbuffer = (byte *)realloc( image.tempbuffer, input_size );
	src = (byte *)(input + input_size);
	texture->numSides = numSides;
	dst = image.tempbuffer;

	// build image representation table
	// NOTE: src = buffer + sizeof(vtf_t) + lowResSize;
	for( i = 0; i < image.num_mips; i++ )
	{
		for( j = 0; j < image.depth; j++ )
		{
			for( k = 0; k < numSides; k++ )
			{
				texture->sides[k].mips[i].layers[j].size = Image_VTFCalcMipmapSize( hdr, i );
				src -= texture->sides[k].mips[i].layers[j].size;
				texture->sides[k].mips[i].layers[j].ofs = src - input;
				texture->sides[k].mips[i].numlayers++;
				texture->sides[k].nummips++;
			}
		}		
	}

	// write to DXT buffer
	for( i = 0; i < texture->numSides; i++ )
	{
		// NOTE: we needs to swap sides order
		vside_t *side = &texture->sides[texture->numSides-i-1];
		if( !oldformat && texture->numSides > 1 && i == 6 )
			continue; // skip envmap if present
		for( j = 0; j < side->nummips; j++ )
		{
			vmip_t	*mip = &side->mips[j];
			if( ignore_mips && j > 0 ) continue;
			for( k = 0; k < mip->numlayers; k++ )
			{
				// NOTE: we needs to swap frames order
				vlayer_t	*layer = &mip->layers[mip->numlayers-k-1];
				memcpy( dst, input + layer->ofs, layer->size );
				out_size += layer->size;
				dst += layer->size;
			}
		}
	}

	// copy swapped buffer back to the input file, because tempbuffer
	// too unreliable place for keep this data
	memcpy((byte *)input, image.tempbuffer, out_size );
	if( ignore_mips ) image.num_mips = 1;
	if( texture ) free( texture );
	image.size = out_size; // merge out size (minus envmap or identical)
}

/*
=============
Image_LoadVTF
=============
*/
bool Image_LoadVTF( const char *name, const byte *buffer, size_t filesize )
{            
	vtf_t	vtf;
	byte	*fin;
	string	shortname;
	bool	oldformat = false;
	int	i, flags, vtfFormat;
	uint	hdrSize, biasSize, resSize, lowResSize;

	fin = (byte *)buffer;
	memcpy( &vtf, fin, sizeof( vtf ));
	hdrSize = LittleLong( vtf.hdr_size );
	biasSize = 0;

	if( LittleLong( vtf.ident ) != VTFHEADER ) return false; // it's not a vtf file, just skip it
	FS_FileBase( name, shortname );

	// bounds check
	i = LittleLong( vtf.ver_major );
	if( i != VTF_VERSION )
	{
		LogPrintf( "Image_LoadVTF: %s has wrong ver (%i should be %i)\n", shortname, i, VTF_VERSION );
		return false;
	}

	i = LittleLong( vtf.ver_minor );
	if( i == VTF_SUBVERSION0 && vtf.hdr_size == 64 )
		oldformat = true;		// 7.0 hasn't envmap for cubemap images
	// all other subversions are valid

	image.width = LittleShort( vtf.width );
	image.height = LittleShort( vtf.height );
	if(!Image_ValidSize( name )) return false;

	// translate VF_flags into IMAGE_flags
	flags = LittleLong( vtf.flags );
	if((flags & VF_ONEBITALPHA) || (flags & VF_EIGHTBITALPHA))
		image.flags |= IMAGE_HAS_ALPHA;
	if( flags & VF_ENVMAP ) image.flags |= IMAGE_CUBEMAP;

	vtfFormat = LittleLong( vtf.imageFormat );
	image.type = Image_VTFFormat( (vtf_format_t)vtfFormat );
	image.depth = LittleLong( vtf.num_frames );
	image.num_mips = LittleLong( vtf.numMipLevels );

	if( image.type == PF_UNKNOWN )
	{
		LogPrintf( "Image_LoadVTF: file (%s) has unknown format %i\n", shortname, vtfFormat );
		return false;		
	}

	lowResSize = Image_VTFCalcLowResSize( &vtf);          
	resSize = Image_VTFCalcImageSize( &vtf, (i == 0));
	i = hdrSize + lowResSize + resSize;

	if( filesize > i )
	{
		// Valve changed format after subversion 3 and higher...
		LogPrintf( "Image_LoadVTF: %s have invalid size\n", name );
		biasSize = filesize - i;
	}
	else if( filesize < i ) return false; // corrupted texture or somewhat

	fin += hdrSize + biasSize + lowResSize; // go to main image
	image.size = resSize; // base size can be merged after swapping

	// convert VTF to DXT
	Image_VTFSwapBuffer( &vtf, fin, resSize, oldformat );

	// FIXME: set IMAGE_HAS_ALPHA and IMAGE_HAS_COLOR properly
	image.flags |= IMAGE_HAS_COLOR;

	if( Image_ForceDecompress())
	{
		int	offset, numsides = 1;
		uint	target = 1;
		byte	*buf = fin;

		// if hardware loader is absent or image not power of two
		// or user want load current side from cubemap we run software decompressing
		if( image.flags & IMAGE_CUBEMAP ) numsides = 6;
		Image_SetPixelFormat( image.width, image.height, image.depth ); // setup
		image.size = image.ptr = 0;
		image.cur_mips = image.num_mips;
		image.num_mips = 0; // clear mipcount

		for( i = 0, offset = 0; i < numsides; i++, buf += offset )
		{
			Image_SetPixelFormat( image.curwidth, image.curheight, image.curdepth );
			offset = image.SizeOfFile; // move pointer

			Image_DecompressDDS( buf, target + i );
		}
		// now we can change type to RGBA
		if( image.hint != IL_HINT_NO ) image.flags &= ~IMAGE_CUBEMAP; // side extracted
		image.type = PF_RGBA_32;
	}
	else
	{
		// vtf files will be uncompressed on a render. requires minimal of info for set this
		image.rgba = (byte *)malloc( image.size );
		memcpy( image.rgba, fin, image.size );
	}
	return true;
}